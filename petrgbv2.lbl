
	{loadaddr:$0401}
{:CASSPORT}
	REM THIS ODD ROUTINE EXISTS CUZ I CAN'T TOTALLY FIGURE OUT THE CASSETTE PORT
	PRINT "{CLEAR}{DOWN:2} INITIALIZE CASSETTE PORT #2? (Y/(N))"
	{:GC}
	FOR I=10 TO 1 STEP -1
	PRINT I;"...";
	FOR J=1 TO 500 
	GET C$ : IF C$<>"" THEN GOTO {:YN}
	NEXT J
	NEXT I
	{:YN}
	IF C$="Y" THEN GOTO {:CP2INIT}
	GOTO {:INITIALIZE}
	{:CP2INIT}
	PRINT
	PRINT " PLEASE WAIT ONE MOMENT...";
	OPEN 1,2,1
	PRINT "ONE MORE SEC..."
	CLOSE 1
	PRINT " OK"
	GOTO {:INITIALIZE}


{:INITIALIZE}
	POKE 59459,255 :REM SET ALL BITS TO OUTPUT
	POKE 59467,PEEK(59467) AND 227 :REM DISABL SHFTREG CB2,&SET TO OUTPUT
	POKE 59468,(PEEK(59468) AND 31) OR 192 : REM SET CB2 LOW
	POKE 59468,PEEK(59468) AND 254 :REM CA1 TRIGGERS FALLING EDGE
	BB=0
	GOSUB {:ARDUPWR} 

{:LOOP}
	PRINT "{CLEAR}{DOWN:2}
	PRINT "  RGB LED CONTROL"
	PRINT "  ---------------"
	pRINT
	PRINT "  SELECT MODE"
	PRINT
	PRINT "  1 ... SOLID COLOR "    
	PRINT "  2 ... RAINBOW      "     
	PRINT "  3 ... BLINKENLIGHTS "     
	PRINT "  4 ... MATRIX"
	PRINT "  5 ... SHIFT REGISTER"
{:INSUB}
	PRINT "  X ... EXIT LED SUBROUTINE"
	PRINT "  Q ... QUIT TO BASIC"
	PRINT "  A ... POWER CYCLE ARDUINO"
	PRINT 
	PRINT
	INPUT "  ENTER SELECTION:";C$	
	PRINT		
	IF C$="" THEN GOTO {:LOOP}
	IF C$="Q" THEN {:BYE}
	IF C$="X" THEN C$="255"
	IF C$="A" THEN GOSUB {:ARDUPWR}
	BB=VAL(C$):REM CONVERTS STRING TO INTEGER, BB=0 IF NONNUMERIC
	IF BB=0 THEN GOTO {:LOOP}
	IF BB=255 THEN {:XSUB}
	GOSUB {:SENDBYTE} :REM SEND MODE SELECTION TO ARDUINO
	ON BB GOTO {:SOLID}, {:RAINBOW}, {:BLINKEN}, {:MATRIX}, {:SHFTREG}
	GOTO {:LOOP}

 {:SOLID}
	PRINT "{CLEAR}{DOWN:2}"
	PRINT " SOLID COLOR MODE"
	INPUT " ENTER R,G,B VALUES (0-255)";R,G,B
	BB=R : GOSUB {:SENDBYTE}
	BB=G : GOSUB {:SENDBYTE}
	BB=B : GOSUB {:SENDBYTE}
	PRINT
	GOTO {:INSUB}

 {:RAINBOW}
	PRINT "{CLEAR}{DOWN:2}"
	PRINT " RAINBOW MODE"
	PRINT
	GOTO {:INSUB}
	
 {:BLINKEN}
	PRINT "{CLEAR}{DOWN:2}"
	PRINT " BLINKENLIGHTS MODE"
	INPUT " ENTER R,G,B VALUES (0-255)";R,G,B
	BB=R : GOSUB {:SENDBYTE}
	BB=G : GOSUB {:SENDBYTE}
	BB=B : GOSUB {:SENDBYTE}
	PRINT
	GOTO {:INSUB}

 {:MATRIX}
	REM MAX # STREAMS,80/40 COLS,UPWARD SCROLL SPEED, SCREEN MEM LOC
	M=4 :C=80 :S$="    ":L=32768
	FOR I=0 TO 24 : PRINT : NEXT I: REM CLEAR SCREEN

	{:MATRIXLOOP}
		GET A$: IF A$<>"" THEN GOTO {:EXITMATRIX} :REM EXIT IF KEYPRESS
		GOSUB {:STREAMS}
		IF RND(1)<.38 THEN GOSUB {:DRIPS} :REM LIKELYHOOD OF DRIP 38%
		GOTO {:MATRIXLOOP}
		
		{:STREAMS}
		REM        CHARACTER STREAMS
		S=RND(1)*M : REM NUMBER OF STREAMS IN THIS LOOP
		FOR I=0 TO S :X(I)=INT(RND(1)*C) :NEXT I :REM STREAM POSITIONS
		REM DEFINE STARTING&ENDING LOCATIONS FOR STREAM, & SPEED
		FOR Y=RND(1)*15 TO RND(1)*7+18 STEP RND(1)+.3 
		FOR I=0 TO S : REM DRAW STREAMS
		POKE L+X(I)+(INT(Y-I)*C),RND(1)*255
		PRINT S$; :REM SCROLL UPWARDS
		NEXT I :NEXT Y :RETURN
		
		{:DRIPS}
		REM        CHARACTER DRIPS
		REM NUMBER OF POSSIBLE DRIPS MAX STREAMS-1
		FOR I=1 TO RND(1)*(M-1)
		DX=RND(1)*C :REM DRIP X POSITION
		FOR Y=1 TO 24 STEP RND(1)+.75 :REM DRAW DRIP
		PY=L+DX+INT(Y)*C
		POKE PY,RND(1)*255 :POKE PY,RND(1)*255 :POKE PY,32
		PRINT S$; : REM SCROLL UP
		NEXT Y :NEXT I :RETURN

	{:EXITMATRIX}
	BB=255 : GOSUB {:SENDBYTE}
	FOR I=0 TO 24 : PRINT : NEXT I
	GOTO {:LOOP}


 {:SHFTREG}
	PRINT "{CLEAR}{DOWN:2}"
	PRINT " SHIFT REGISTER MODE"
	PRINT
	INPUT " ENTER R,G,B VALUES (0-255)";R,G,B
	BB=R : GOSUB {:SENDBYTE}
	BB=G : GOSUB {:SENDBYTE}
	BB=B : GOSUB {:SENDBYTE}
	INPUT " ENTER LED MATRIX REFRESH DELAY (0-255)";BB
	GOSUB {:SENDBYTE}
	PRINT
	PRINT " PRESS M TO MUTE AUDIO"
	PRINT " PRESS ANY OTHER KEY TO CONTINUE"""
	BB=1
	{:GETA}
	GET A$
	IF A$="" THEN GOTO  {:GETA}
	IF A$="M" THEN BB=0
	GOSUB {:SENDBYTE}
	POKE 59467,PEEK(59467)AND227OR16 :REM ENABLE SHIFT REG
	T=0
	D=0	
	P$="+"
	REM SET UP FOR DECIMAL TO BINARY CALCULATIONS
	Z(1)=1
	FOR I=2 TO 8
	Z(I)=Z(I-1)*2
	NEXT I

	{:SHIFTLOOP}
		POKE 59464,T : REM SETS SHIFT REGISTER TIMER
		POKE 59466,D : REM OUPUTS ON SHIFT REGISTER	

		PRINT "{CLEAR}{DOWN:2} SHIFT REGISTER MODE"
		PRINT
		PRINT " TIMER:";T
		PRINT
		PRINT " DATA:";
		REM CALCULATE AND DISPLAY WHICH BITS ARE ON
		PRINT (DAND1);P$;(DAND2);P$;(DAND4);P$;(DAND8);P$;
		PRINT (DAND16);P$;(DAND32);P$;(DAND64);P$;(DAND128);"=";D
		PRINT
		PRINT " A - DECREASE DATA-10        E - DECREASE TIMER-10"
		PRINT " S - DECREASE DATA-1         R - DECREASE TIMER-1"
		PRINT " D - SET DATA TO 170         T - SET TIMER TO 128"
		PRINT " F - INCREASE DATA+1         Y - INCREASE TIMER+1"
		PRINT " G - INCREASE DATA+10        U - INCREASE TIMER+10"	
		PRINT " X - EXIT SUBROUTINE         Q - QUIT TO BASIC" 
		PRINT " 0 - SET TIMER & DATA TO 0   C - CYCLE AUTOMATICALLY"
		PRINT	
		PRINT " NUMBERS 1 THROUGH 8 SET CORRESPONDING BITS ON DATA STREAM"
		
		{:GETKEY}
		GET K$
		IF K$="" THEN {:GETKEY}	
		K=VAL(K$)
		IF K=0 THEN GOTO {:ALPHA}

		{:BITTOGGLE}
		K=Z(K)
		D=(NOT(D AND K)) AND (NOT(NOT D AND NOT K)):REM XOR BITS
		GOTO {:SHIFTLOOP}

		{:ALPHA}
		IF K$="E" THEN T=T-10
		IF K$="R" THEN T=T-1
		IF K$="T" THEN GOTO {:CYCLETIMER}
		IF K$="Y" THEN T=T+1
		IF K$="U" THEN T=T+10
		IF K$="A" THEN D=D-10
		IF K$="S" THEN D=D-1
		IF K$="D" THEN GOTO {:CYCLEDATA}
		IF K$="F" THEN D=D+1
		IF K$="G" THEN D=D+10
		IF K$="0" THEN D=0:T=0
		IF K$="X" THEN GOTO {:INITIALIZE}
		IF K$="Q" THEN GOTO {:SHFTQUIT}
		IF D<=-1 THEN D=255
		IF D>=256 THEN D=0 
		IF T<=-1 THEN T=255
		IF T>=256 THEN T=0
		GOTO {:SHIFTLOOP}	


		{:CYCLETIMER}
			FOR T=0 TO 255
				POKE 59464,T : REM SETS SHIFT REGISTER TIMER
				PRINT "{CLEAR}{DOWN:2} SHIFT REGISTER MODE"
				PRINT
				PRINT " TIMER:";T;"  DATA:";D
				FOR I=1 TO 50
				GET K$ : IF K$<>"" THEN GOTO {:SHIFTLOOP}
				NEXT I
			NEXT T
		 GOTO {:CYCLETIMER}

		{:CYCLEDATA}
			FOR D=0 TO 255
				POKE 59466,D : REM OUPUTS ON SHIFT REGISTER	
				PRINT "{CLEAR}{DOWN:2} SHIFT REGISTER MODE"
				PRINT
				PRINT " TIMER:";T;"  DATA:";D			
				FOR I=1 TO 50				
				GET K$ : IF K$<>"" THEN GOTO {:SHIFTLOOP}
				NEXT I
			NEXT D
		 GOTO {:CYCLEDATA}


	{:SHFTQUIT}
	PRINT
	PRINT " QUITING TO BASIC"
	PRINT " SHIFT REGISTER MODE IS ACTIVE"
	END


 {:ARDUPWR}
	PRINT "{CLEAR}{DOWN:2}POWER CYCLING ARDUINO"
	POKE 59456,(PEEK(59456)OR16) :REM CASSETTE PORT 2 MOTOR OFF
	PRINT 
	PRINT "ONE MOMENT";
	FOR J=1 TO 100 :PRINT ".";:NEXT J
	POKE 59456,(PEEK(59456)AND239):REM CASSETTE PORT 2 MOTOR ON
	FOR J=1 TO 600 :PRINT ".";:NEXT J
	PRINT : PRINT "OK"
	RETURN

{:XSUB}
	PRINT
	PRINT " EXITING SUBROUTINE..."
	GOSUB {:SENDBYTE}
	PRINT " OK"
	GOTO {:LOOP}	




{:SENDBYTE}
	REM SEND BB BYTE
	POKE 59468,PEEK(59468) OR 224 :REM SET CB2 HIGH TO SIGNAL ARDUINO
	POKE 59457,BB :REM SEND BYTE
	POKE 59468,(PEEK(59468) AND 31) OR 192 :REM RETURN CB2 TO LOW STATE
	
	{:WAITCA1}
	REM PART OF SENDBYTE SUBROUTINE, BUT DOESN'T STRICTLY HAVE TO BE
	IF (PEEK(59469)AND2)=0 THEN {:WAITCA1} : REM WAIT FOR CA1 STROBE FROM ARDUINO
	RETURN

{:BYE}
	PRINT
	PRINT "EXITING RGB CONTROL"
	END

{:REMINDERS}
	REM REMINDERS
	POKE 59468,PEEK(59468) OR 224 :REM SET CB2 HIGH
	POKE 59468,(PEEK(59468) AND 31) OR 192 :END :REM SET CB2 LOW
	POKE 59459,255 :REM SET ALL BITS TO OUTPUT
	POKE 59467,PEEK(59467) AND 227 :REM DISABL SHFTREG CB2,&SET TO OUTPUT
	POKE 59467,PEEK(59467)AND227OR16 :REM ENABLE SHIFT REG
	POKE 59464,T : REM SETS SHIFT REGISTER TIMER
	POKE 59466,SHFTDATA : REM OUPUTS ON SHIFT REGISTER
	POKE 59471,J :REM SEND DATA OUT
	POKE 59457,J :REM SEND DATA OUT AND RESET CA1 FLAG
	POKE 59468,PEEK(59468) AND 254 :REM CA1 TRIGGERS FALLING EDGE
	POKE 59468,PEEK(59468) OR 1 :REM CA1 TRGGERS RISING EDGE
	IF (PEEK(59469) AND 2)=0 THEN WHATEVER :REM WAIT FOR CA1 TO GO HIGH
	POKE 59467,PEEK(59467) OR 1 :REM DATA LATCHED WHEN CA1 TRIGGERS
	POKE 59468,PEEK(59468) OR 224 :REM SET CB2 HIGH
	POKE 59456,(PEEK(59456)OR16) :REM TURN OFF CASSETTE 2 MOTOR/ARDUINO
	POKE 59456,(PEEK(59456)AND239):REM TURN ON CASSETTE 2 MOTOR/ARDUINO

